/* automatically generated by rust-bindgen 0.72.0 */

pub const HAL_MAX_DELAY: u32 = 4294967295;
pub const HAL_UART_STATE_RESET: u32 = 0;
pub const HAL_UART_STATE_READY: u32 = 32;
pub const HAL_UART_STATE_BUSY: u32 = 36;
pub const HAL_UART_STATE_BUSY_TX: u32 = 33;
pub const HAL_UART_STATE_BUSY_RX: u32 = 34;
pub const HAL_UART_STATE_BUSY_TX_RX: u32 = 35;
pub const HAL_UART_STATE_TIMEOUT: u32 = 160;
pub const HAL_UART_STATE_ERROR: u32 = 224;
pub const HAL_UART_ERROR_NONE: u32 = 0;
pub const HAL_UART_ERROR_PE: u32 = 1;
pub const HAL_UART_ERROR_NE: u32 = 2;
pub const HAL_UART_ERROR_FE: u32 = 4;
pub const HAL_UART_ERROR_ORE: u32 = 8;
pub const HAL_UART_ERROR_DMA: u32 = 16;
pub const HAL_UART_ERROR_RTO: u32 = 32;
pub const HAL_UART_TIMEOUT_VALUE: u32 = 33554431;
pub const HAL_UART_RECEPTION_STANDARD: u32 = 0;
pub const HAL_UART_RECEPTION_TOIDLE: u32 = 1;
pub const HAL_UART_RECEPTION_TORTO: u32 = 2;
pub const HAL_UART_RECEPTION_TOCHARMATCH: u32 = 3;
pub const HAL_UART_RXEVENT_TC: u32 = 0;
pub const HAL_UART_RXEVENT_HT: u32 = 1;
pub const HAL_UART_RXEVENT_IDLE: u32 = 2;
#[doc = " @brief DMA Controller"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct DMA_Channel_TypeDef {
    #[doc = "< DMA channel x configuration register"]
    pub CCR: u32,
    #[doc = "< DMA channel x number of data register"]
    pub CNDTR: u32,
    #[doc = "< DMA channel x peripheral address register"]
    pub CPAR: u32,
    #[doc = "< DMA channel x memory address register"]
    pub CMAR: u32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of DMA_Channel_TypeDef"][::core::mem::size_of::<DMA_Channel_TypeDef>() - 16usize];
    ["Alignment of DMA_Channel_TypeDef"][::core::mem::align_of::<DMA_Channel_TypeDef>() - 4usize];
    ["Offset of field: DMA_Channel_TypeDef::CCR"]
        [::core::mem::offset_of!(DMA_Channel_TypeDef, CCR) - 0usize];
    ["Offset of field: DMA_Channel_TypeDef::CNDTR"]
        [::core::mem::offset_of!(DMA_Channel_TypeDef, CNDTR) - 4usize];
    ["Offset of field: DMA_Channel_TypeDef::CPAR"]
        [::core::mem::offset_of!(DMA_Channel_TypeDef, CPAR) - 8usize];
    ["Offset of field: DMA_Channel_TypeDef::CMAR"]
        [::core::mem::offset_of!(DMA_Channel_TypeDef, CMAR) - 12usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct DMA_TypeDef {
    #[doc = "< DMA interrupt status register,                            Address offset: 0x00"]
    pub ISR: u32,
    #[doc = "< DMA interrupt flag clear register,                        Address offset: 0x04"]
    pub IFCR: u32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of DMA_TypeDef"][::core::mem::size_of::<DMA_TypeDef>() - 8usize];
    ["Alignment of DMA_TypeDef"][::core::mem::align_of::<DMA_TypeDef>() - 4usize];
    ["Offset of field: DMA_TypeDef::ISR"][::core::mem::offset_of!(DMA_TypeDef, ISR) - 0usize];
    ["Offset of field: DMA_TypeDef::IFCR"][::core::mem::offset_of!(DMA_TypeDef, IFCR) - 4usize];
};
#[doc = " @brief Universal Synchronous Asynchronous Receiver Transmitter"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct USART_TypeDef {
    #[doc = "< USART Control register 1,                 Address offset: 0x00"]
    pub CR1: u32,
    #[doc = "< USART Control register 2,                 Address offset: 0x04"]
    pub CR2: u32,
    #[doc = "< USART Control register 3,                 Address offset: 0x08"]
    pub CR3: u32,
    #[doc = "< USART Baud rate register,                 Address offset: 0x0C"]
    pub BRR: u32,
    #[doc = "< USART Guard time and prescaler register,  Address offset: 0x10"]
    pub GTPR: u32,
    #[doc = "< USART Receiver Time Out register,         Address offset: 0x14"]
    pub RTOR: u32,
    #[doc = "< USART Request register,                   Address offset: 0x18"]
    pub RQR: u32,
    #[doc = "< USART Interrupt and status register,      Address offset: 0x1C"]
    pub ISR: u32,
    #[doc = "< USART Interrupt flag Clear register,      Address offset: 0x20"]
    pub ICR: u32,
    #[doc = "< USART Receive Data register,              Address offset: 0x24"]
    pub RDR: u16,
    #[doc = "< Reserved, 0x26"]
    pub RESERVED1: u16,
    #[doc = "< USART Transmit Data register,             Address offset: 0x28"]
    pub TDR: u16,
    #[doc = "< Reserved, 0x2A"]
    pub RESERVED2: u16,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of USART_TypeDef"][::core::mem::size_of::<USART_TypeDef>() - 44usize];
    ["Alignment of USART_TypeDef"][::core::mem::align_of::<USART_TypeDef>() - 4usize];
    ["Offset of field: USART_TypeDef::CR1"][::core::mem::offset_of!(USART_TypeDef, CR1) - 0usize];
    ["Offset of field: USART_TypeDef::CR2"][::core::mem::offset_of!(USART_TypeDef, CR2) - 4usize];
    ["Offset of field: USART_TypeDef::CR3"][::core::mem::offset_of!(USART_TypeDef, CR3) - 8usize];
    ["Offset of field: USART_TypeDef::BRR"][::core::mem::offset_of!(USART_TypeDef, BRR) - 12usize];
    ["Offset of field: USART_TypeDef::GTPR"]
        [::core::mem::offset_of!(USART_TypeDef, GTPR) - 16usize];
    ["Offset of field: USART_TypeDef::RTOR"]
        [::core::mem::offset_of!(USART_TypeDef, RTOR) - 20usize];
    ["Offset of field: USART_TypeDef::RQR"][::core::mem::offset_of!(USART_TypeDef, RQR) - 24usize];
    ["Offset of field: USART_TypeDef::ISR"][::core::mem::offset_of!(USART_TypeDef, ISR) - 28usize];
    ["Offset of field: USART_TypeDef::ICR"][::core::mem::offset_of!(USART_TypeDef, ICR) - 32usize];
    ["Offset of field: USART_TypeDef::RDR"][::core::mem::offset_of!(USART_TypeDef, RDR) - 36usize];
    ["Offset of field: USART_TypeDef::RESERVED1"]
        [::core::mem::offset_of!(USART_TypeDef, RESERVED1) - 38usize];
    ["Offset of field: USART_TypeDef::TDR"][::core::mem::offset_of!(USART_TypeDef, TDR) - 40usize];
    ["Offset of field: USART_TypeDef::RESERVED2"]
        [::core::mem::offset_of!(USART_TypeDef, RESERVED2) - 42usize];
};
pub const HAL_StatusTypeDef_HAL_OK: HAL_StatusTypeDef = 0;
pub const HAL_StatusTypeDef_HAL_ERROR: HAL_StatusTypeDef = 1;
pub const HAL_StatusTypeDef_HAL_BUSY: HAL_StatusTypeDef = 2;
pub const HAL_StatusTypeDef_HAL_TIMEOUT: HAL_StatusTypeDef = 3;
#[doc = " @brief  HAL Status structures definition"]
pub type HAL_StatusTypeDef = ::core::ffi::c_uint;
pub const HAL_LockTypeDef_HAL_UNLOCKED: HAL_LockTypeDef = 0;
pub const HAL_LockTypeDef_HAL_LOCKED: HAL_LockTypeDef = 1;
#[doc = " @brief  HAL Lock structures definition"]
pub type HAL_LockTypeDef = ::core::ffi::c_uint;
#[doc = " @brief  DMA Configuration Structure definition"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct DMA_InitTypeDef {
    #[doc = "< Specifies if the data will be transferred from memory to peripheral,\nfrom memory to memory or from peripheral to memory.\nThis parameter can be a value of @ref DMA_Data_transfer_direction"]
    pub Direction: u32,
    #[doc = "< Specifies whether the Peripheral address register should be incremented or not.\nThis parameter can be a value of @ref DMA_Peripheral_incremented_mode"]
    pub PeriphInc: u32,
    #[doc = "< Specifies whether the memory address register should be incremented or not.\nThis parameter can be a value of @ref DMA_Memory_incremented_mode"]
    pub MemInc: u32,
    #[doc = "< Specifies the Peripheral data width.\nThis parameter can be a value of @ref DMA_Peripheral_data_size"]
    pub PeriphDataAlignment: u32,
    #[doc = "< Specifies the Memory data width.\nThis parameter can be a value of @ref DMA_Memory_data_size"]
    pub MemDataAlignment: u32,
    #[doc = "< Specifies the operation mode of the DMAy Channelx.\nThis parameter can be a value of @ref DMA_mode\n@note The circular buffer mode cannot be used if the memory-to-memory\ndata transfer is configured on the selected Channel"]
    pub Mode: u32,
    #[doc = "< Specifies the software priority for the DMAy Channelx.\nThis parameter can be a value of @ref DMA_Priority_level"]
    pub Priority: u32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of DMA_InitTypeDef"][::core::mem::size_of::<DMA_InitTypeDef>() - 28usize];
    ["Alignment of DMA_InitTypeDef"][::core::mem::align_of::<DMA_InitTypeDef>() - 4usize];
    ["Offset of field: DMA_InitTypeDef::Direction"]
        [::core::mem::offset_of!(DMA_InitTypeDef, Direction) - 0usize];
    ["Offset of field: DMA_InitTypeDef::PeriphInc"]
        [::core::mem::offset_of!(DMA_InitTypeDef, PeriphInc) - 4usize];
    ["Offset of field: DMA_InitTypeDef::MemInc"]
        [::core::mem::offset_of!(DMA_InitTypeDef, MemInc) - 8usize];
    ["Offset of field: DMA_InitTypeDef::PeriphDataAlignment"]
        [::core::mem::offset_of!(DMA_InitTypeDef, PeriphDataAlignment) - 12usize];
    ["Offset of field: DMA_InitTypeDef::MemDataAlignment"]
        [::core::mem::offset_of!(DMA_InitTypeDef, MemDataAlignment) - 16usize];
    ["Offset of field: DMA_InitTypeDef::Mode"]
        [::core::mem::offset_of!(DMA_InitTypeDef, Mode) - 20usize];
    ["Offset of field: DMA_InitTypeDef::Priority"]
        [::core::mem::offset_of!(DMA_InitTypeDef, Priority) - 24usize];
};
#[doc = "< DMA not yet initialized or disabled"]
pub const HAL_DMA_StateTypeDef_HAL_DMA_STATE_RESET: HAL_DMA_StateTypeDef = 0;
#[doc = "< DMA initialized and ready for use"]
pub const HAL_DMA_StateTypeDef_HAL_DMA_STATE_READY: HAL_DMA_StateTypeDef = 1;
#[doc = "< DMA process is ongoing"]
pub const HAL_DMA_StateTypeDef_HAL_DMA_STATE_BUSY: HAL_DMA_StateTypeDef = 2;
#[doc = "< DMA timeout state"]
pub const HAL_DMA_StateTypeDef_HAL_DMA_STATE_TIMEOUT: HAL_DMA_StateTypeDef = 3;
#[doc = " @brief  HAL DMA State structures definition"]
pub type HAL_DMA_StateTypeDef = ::core::ffi::c_uint;
#[doc = " @brief  DMA handle Structure definition"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __DMA_HandleTypeDef {
    #[doc = "< Register base address"]
    pub Instance: *mut DMA_Channel_TypeDef,
    #[doc = "< DMA communication parameters"]
    pub Init: DMA_InitTypeDef,
    #[doc = "< DMA locking object"]
    pub Lock: HAL_LockTypeDef,
    #[doc = "< DMA transfer state"]
    pub State: HAL_DMA_StateTypeDef,
    #[doc = "< Parent object state"]
    pub Parent: *mut ::core::ffi::c_void,
    #[doc = "< DMA transfer complete callback"]
    pub XferCpltCallback:
        ::core::option::Option<unsafe extern "C" fn(hdma: *mut __DMA_HandleTypeDef)>,
    #[doc = "< DMA Half transfer complete callback"]
    pub XferHalfCpltCallback:
        ::core::option::Option<unsafe extern "C" fn(hdma: *mut __DMA_HandleTypeDef)>,
    #[doc = "< DMA transfer error callback"]
    pub XferErrorCallback:
        ::core::option::Option<unsafe extern "C" fn(hdma: *mut __DMA_HandleTypeDef)>,
    #[doc = "< DMA transfer abort callback"]
    pub XferAbortCallback:
        ::core::option::Option<unsafe extern "C" fn(hdma: *mut __DMA_HandleTypeDef)>,
    #[doc = "< DMA Error code"]
    pub ErrorCode: u32,
    #[doc = "< DMA Channel Base Address"]
    pub DmaBaseAddress: *mut DMA_TypeDef,
    #[doc = "< DMA Channel Index"]
    pub ChannelIndex: u32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of __DMA_HandleTypeDef"][::core::mem::size_of::<__DMA_HandleTypeDef>() - 72usize];
    ["Alignment of __DMA_HandleTypeDef"][::core::mem::align_of::<__DMA_HandleTypeDef>() - 4usize];
    ["Offset of field: __DMA_HandleTypeDef::Instance"]
        [::core::mem::offset_of!(__DMA_HandleTypeDef, Instance) - 0usize];
    ["Offset of field: __DMA_HandleTypeDef::Init"]
        [::core::mem::offset_of!(__DMA_HandleTypeDef, Init) - 4usize];
    ["Offset of field: __DMA_HandleTypeDef::Lock"]
        [::core::mem::offset_of!(__DMA_HandleTypeDef, Lock) - 32usize];
    ["Offset of field: __DMA_HandleTypeDef::State"]
        [::core::mem::offset_of!(__DMA_HandleTypeDef, State) - 36usize];
    ["Offset of field: __DMA_HandleTypeDef::Parent"]
        [::core::mem::offset_of!(__DMA_HandleTypeDef, Parent) - 40usize];
    ["Offset of field: __DMA_HandleTypeDef::XferCpltCallback"]
        [::core::mem::offset_of!(__DMA_HandleTypeDef, XferCpltCallback) - 44usize];
    ["Offset of field: __DMA_HandleTypeDef::XferHalfCpltCallback"]
        [::core::mem::offset_of!(__DMA_HandleTypeDef, XferHalfCpltCallback) - 48usize];
    ["Offset of field: __DMA_HandleTypeDef::XferErrorCallback"]
        [::core::mem::offset_of!(__DMA_HandleTypeDef, XferErrorCallback) - 52usize];
    ["Offset of field: __DMA_HandleTypeDef::XferAbortCallback"]
        [::core::mem::offset_of!(__DMA_HandleTypeDef, XferAbortCallback) - 56usize];
    ["Offset of field: __DMA_HandleTypeDef::ErrorCode"]
        [::core::mem::offset_of!(__DMA_HandleTypeDef, ErrorCode) - 60usize];
    ["Offset of field: __DMA_HandleTypeDef::DmaBaseAddress"]
        [::core::mem::offset_of!(__DMA_HandleTypeDef, DmaBaseAddress) - 64usize];
    ["Offset of field: __DMA_HandleTypeDef::ChannelIndex"]
        [::core::mem::offset_of!(__DMA_HandleTypeDef, ChannelIndex) - 68usize];
};
#[doc = " @brief  DMA handle Structure definition"]
pub type DMA_HandleTypeDef = __DMA_HandleTypeDef;
#[doc = " @brief UART Init Structure definition"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct UART_InitTypeDef {
    #[doc = "< This member configures the UART communication baud rate.\nThe baud rate register is computed using the following formula:\n- If oversampling is 16 or in LIN mode,\nBaud Rate Register = ((uart_ker_ck) / ((huart->Init.BaudRate)))\n- If oversampling is 8,\nBaud Rate Register[15:4] = ((2 * uart_ker_ck) /\n((huart->Init.BaudRate)))[15:4]\nBaud Rate Register[3] =  0\nBaud Rate Register[2:0] =  (((2 * uart_ker_ck) /\n((huart->Init.BaudRate)))[3:0]) >> 1\nwhere uart_ker_ck is the UART input clock"]
    pub BaudRate: u32,
    #[doc = "< Specifies the number of data bits transmitted or received in a frame.\nThis parameter can be a value of @ref UARTEx_Word_Length."]
    pub WordLength: u32,
    #[doc = "< Specifies the number of stop bits transmitted.\nThis parameter can be a value of @ref UART_Stop_Bits."]
    pub StopBits: u32,
    #[doc = "< Specifies the parity mode.\nThis parameter can be a value of @ref UART_Parity\n@note When parity is enabled, the computed parity is inserted\nat the MSB position of the transmitted data (9th bit when\nthe word length is set to 9 data bits; 8th bit when the\nword length is set to 8 data bits)."]
    pub Parity: u32,
    #[doc = "< Specifies whether the Receive or Transmit mode is enabled or disabled.\nThis parameter can be a value of @ref UART_Mode."]
    pub Mode: u32,
    #[doc = "< Specifies whether the hardware flow control mode is enabled\nor disabled.\nThis parameter can be a value of @ref UART_Hardware_Flow_Control."]
    pub HwFlowCtl: u32,
    #[doc = "< Specifies whether the Over sampling 8 is enabled or disabled,\nto achieve higher speed (up to f_PCLK/8).\nThis parameter can be a value of @ref UART_Over_Sampling."]
    pub OverSampling: u32,
    #[doc = "< Specifies whether a single sample or three samples' majority vote is selected.\nSelecting the single sample method increases the receiver tolerance to clock\ndeviations. This parameter can be a value of @ref UART_OneBit_Sampling."]
    pub OneBitSampling: u32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of UART_InitTypeDef"][::core::mem::size_of::<UART_InitTypeDef>() - 32usize];
    ["Alignment of UART_InitTypeDef"][::core::mem::align_of::<UART_InitTypeDef>() - 4usize];
    ["Offset of field: UART_InitTypeDef::BaudRate"]
        [::core::mem::offset_of!(UART_InitTypeDef, BaudRate) - 0usize];
    ["Offset of field: UART_InitTypeDef::WordLength"]
        [::core::mem::offset_of!(UART_InitTypeDef, WordLength) - 4usize];
    ["Offset of field: UART_InitTypeDef::StopBits"]
        [::core::mem::offset_of!(UART_InitTypeDef, StopBits) - 8usize];
    ["Offset of field: UART_InitTypeDef::Parity"]
        [::core::mem::offset_of!(UART_InitTypeDef, Parity) - 12usize];
    ["Offset of field: UART_InitTypeDef::Mode"]
        [::core::mem::offset_of!(UART_InitTypeDef, Mode) - 16usize];
    ["Offset of field: UART_InitTypeDef::HwFlowCtl"]
        [::core::mem::offset_of!(UART_InitTypeDef, HwFlowCtl) - 20usize];
    ["Offset of field: UART_InitTypeDef::OverSampling"]
        [::core::mem::offset_of!(UART_InitTypeDef, OverSampling) - 24usize];
    ["Offset of field: UART_InitTypeDef::OneBitSampling"]
        [::core::mem::offset_of!(UART_InitTypeDef, OneBitSampling) - 28usize];
};
#[doc = " @brief  UART Advanced Features initialization structure definition"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct UART_AdvFeatureInitTypeDef {
    #[doc = "< Specifies which advanced UART features is initialized. Several\nAdvanced Features may be initialized at the same time .\nThis parameter can be a value of\n@ref UART_Advanced_Features_Initialization_Type."]
    pub AdvFeatureInit: u32,
    #[doc = "< Specifies whether the TX pin active level is inverted.\nThis parameter can be a value of @ref UART_Tx_Inv."]
    pub TxPinLevelInvert: u32,
    #[doc = "< Specifies whether the RX pin active level is inverted.\nThis parameter can be a value of @ref UART_Rx_Inv."]
    pub RxPinLevelInvert: u32,
    #[doc = "< Specifies whether data are inverted (positive/direct logic\nvs negative/inverted logic).\nThis parameter can be a value of @ref UART_Data_Inv."]
    pub DataInvert: u32,
    #[doc = "< Specifies whether TX and RX pins are swapped.\nThis parameter can be a value of @ref UART_Rx_Tx_Swap."]
    pub Swap: u32,
    #[doc = "< Specifies whether the reception overrun detection is disabled.\nThis parameter can be a value of @ref UART_Overrun_Disable."]
    pub OverrunDisable: u32,
    #[doc = "< Specifies whether the DMA is disabled in case of reception error.\nThis parameter can be a value of @ref UART_DMA_Disable_on_Rx_Error."]
    pub DMADisableonRxError: u32,
    #[doc = "< Specifies whether auto Baud rate detection is enabled.\nThis parameter can be a value of @ref UART_AutoBaudRate_Enable."]
    pub AutoBaudRateEnable: u32,
    #[doc = "< If auto Baud rate detection is enabled, specifies how the rate\ndetection is carried out.\nThis parameter can be a value of @ref UART_AutoBaud_Rate_Mode."]
    pub AutoBaudRateMode: u32,
    #[doc = "< Specifies whether MSB is sent first on UART line.\nThis parameter can be a value of @ref UART_MSB_First."]
    pub MSBFirst: u32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of UART_AdvFeatureInitTypeDef"]
        [::core::mem::size_of::<UART_AdvFeatureInitTypeDef>() - 40usize];
    ["Alignment of UART_AdvFeatureInitTypeDef"]
        [::core::mem::align_of::<UART_AdvFeatureInitTypeDef>() - 4usize];
    ["Offset of field: UART_AdvFeatureInitTypeDef::AdvFeatureInit"]
        [::core::mem::offset_of!(UART_AdvFeatureInitTypeDef, AdvFeatureInit) - 0usize];
    ["Offset of field: UART_AdvFeatureInitTypeDef::TxPinLevelInvert"]
        [::core::mem::offset_of!(UART_AdvFeatureInitTypeDef, TxPinLevelInvert) - 4usize];
    ["Offset of field: UART_AdvFeatureInitTypeDef::RxPinLevelInvert"]
        [::core::mem::offset_of!(UART_AdvFeatureInitTypeDef, RxPinLevelInvert) - 8usize];
    ["Offset of field: UART_AdvFeatureInitTypeDef::DataInvert"]
        [::core::mem::offset_of!(UART_AdvFeatureInitTypeDef, DataInvert) - 12usize];
    ["Offset of field: UART_AdvFeatureInitTypeDef::Swap"]
        [::core::mem::offset_of!(UART_AdvFeatureInitTypeDef, Swap) - 16usize];
    ["Offset of field: UART_AdvFeatureInitTypeDef::OverrunDisable"]
        [::core::mem::offset_of!(UART_AdvFeatureInitTypeDef, OverrunDisable) - 20usize];
    ["Offset of field: UART_AdvFeatureInitTypeDef::DMADisableonRxError"]
        [::core::mem::offset_of!(UART_AdvFeatureInitTypeDef, DMADisableonRxError) - 24usize];
    ["Offset of field: UART_AdvFeatureInitTypeDef::AutoBaudRateEnable"]
        [::core::mem::offset_of!(UART_AdvFeatureInitTypeDef, AutoBaudRateEnable) - 28usize];
    ["Offset of field: UART_AdvFeatureInitTypeDef::AutoBaudRateMode"]
        [::core::mem::offset_of!(UART_AdvFeatureInitTypeDef, AutoBaudRateMode) - 32usize];
    ["Offset of field: UART_AdvFeatureInitTypeDef::MSBFirst"]
        [::core::mem::offset_of!(UART_AdvFeatureInitTypeDef, MSBFirst) - 36usize];
};
#[doc = " @brief HAL UART State definition\n @note  HAL UART State value is a combination of 2 different substates:\n        gState and RxState (see @ref UART_State_Definition).\n        - gState contains UART state information related to global Handle management\n          and also information related to Tx operations.\n          gState value coding follow below described bitmap :\n          b7-b6  Error information\n             00 : No Error\n             01 : (Not Used)\n             10 : Timeout\n             11 : Error\n          b5     Peripheral initialization status\n             0  : Reset (Peripheral not initialized)\n             1  : Init done (Peripheral initialized. HAL UART Init function already called)\n          b4-b3  (not used)\n             xx : Should be set to 00\n          b2     Intrinsic process state\n             0  : Ready\n             1  : Busy (Peripheral busy with some configuration or internal operations)\n          b1     (not used)\n             x  : Should be set to 0\n          b0     Tx state\n             0  : Ready (no Tx operation ongoing)\n             1  : Busy (Tx operation ongoing)\n        - RxState contains information related to Rx operations.\n          RxState value coding follow below described bitmap :\n          b7-b6  (not used)\n             xx : Should be set to 00\n          b5     Peripheral initialization status\n             0  : Reset (Peripheral not initialized)\n             1  : Init done (Peripheral initialized)\n          b4-b2  (not used)\n            xxx : Should be set to 000\n          b1     Rx state\n             0  : Ready (no Rx operation ongoing)\n             1  : Busy (Rx operation ongoing)\n          b0     (not used)\n             x  : Should be set to 0."]
pub type HAL_UART_StateTypeDef = u32;
#[doc = " @brief HAL UART Reception type definition\n @note  HAL UART Reception type value aims to identify which type of Reception is ongoing.\n        This parameter can be a value of @ref UART_Reception_Type_Values :\n           HAL_UART_RECEPTION_STANDARD         = 0x00U,\n           HAL_UART_RECEPTION_TOIDLE           = 0x01U,\n           HAL_UART_RECEPTION_TORTO            = 0x02U,\n           HAL_UART_RECEPTION_TOCHARMATCH      = 0x03U,"]
pub type HAL_UART_RxTypeTypeDef = u32;
#[doc = " @brief HAL UART Rx Event type definition\n @note  HAL UART Rx Event type value aims to identify which type of Event has occurred\n        leading to call of the RxEvent callback.\n        This parameter can be a value of @ref UART_RxEvent_Type_Values :\n           HAL_UART_RXEVENT_TC                 = 0x00U,\n           HAL_UART_RXEVENT_HT                 = 0x01U,\n           HAL_UART_RXEVENT_IDLE               = 0x02U,"]
pub type HAL_UART_RxEventTypeTypeDef = u32;
#[doc = " @brief  UART handle Structure definition"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __UART_HandleTypeDef {
    #[doc = "< UART registers base address"]
    pub Instance: *mut USART_TypeDef,
    #[doc = "< UART communication parameters"]
    pub Init: UART_InitTypeDef,
    #[doc = "< UART Advanced Features initialization parameters"]
    pub AdvancedInit: UART_AdvFeatureInitTypeDef,
    #[doc = "< Pointer to UART Tx transfer Buffer"]
    pub pTxBuffPtr: *const u8,
    #[doc = "< UART Tx Transfer size"]
    pub TxXferSize: u16,
    #[doc = "< UART Tx Transfer Counter"]
    pub TxXferCount: u16,
    #[doc = "< Pointer to UART Rx transfer Buffer"]
    pub pRxBuffPtr: *mut u8,
    #[doc = "< UART Rx Transfer size"]
    pub RxXferSize: u16,
    #[doc = "< UART Rx Transfer Counter"]
    pub RxXferCount: u16,
    #[doc = "< UART Rx RDR register mask"]
    pub Mask: u16,
    #[doc = "< Type of ongoing reception"]
    pub ReceptionType: HAL_UART_RxTypeTypeDef,
    #[doc = "< Type of Rx Event"]
    pub RxEventType: HAL_UART_RxEventTypeTypeDef,
    #[doc = "< Function pointer on Rx IRQ handler"]
    pub RxISR: ::core::option::Option<unsafe extern "C" fn(huart: *mut __UART_HandleTypeDef)>,
    #[doc = "< Function pointer on Tx IRQ handler"]
    pub TxISR: ::core::option::Option<unsafe extern "C" fn(huart: *mut __UART_HandleTypeDef)>,
    #[doc = "< UART Tx DMA Handle parameters"]
    pub hdmatx: *mut DMA_HandleTypeDef,
    #[doc = "< UART Rx DMA Handle parameters"]
    pub hdmarx: *mut DMA_HandleTypeDef,
    #[doc = "< Locking object"]
    pub Lock: HAL_LockTypeDef,
    #[doc = "< UART state information related to global Handle management\nand also related to Tx operations. This parameter\ncan be a value of @ref HAL_UART_StateTypeDef"]
    pub gState: HAL_UART_StateTypeDef,
    #[doc = "< UART state information related to Rx operations. This\nparameter can be a value of @ref HAL_UART_StateTypeDef"]
    pub RxState: HAL_UART_StateTypeDef,
    #[doc = "< UART Error code"]
    pub ErrorCode: u32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of __UART_HandleTypeDef"][::core::mem::size_of::<__UART_HandleTypeDef>() - 136usize];
    ["Alignment of __UART_HandleTypeDef"][::core::mem::align_of::<__UART_HandleTypeDef>() - 4usize];
    ["Offset of field: __UART_HandleTypeDef::Instance"]
        [::core::mem::offset_of!(__UART_HandleTypeDef, Instance) - 0usize];
    ["Offset of field: __UART_HandleTypeDef::Init"]
        [::core::mem::offset_of!(__UART_HandleTypeDef, Init) - 4usize];
    ["Offset of field: __UART_HandleTypeDef::AdvancedInit"]
        [::core::mem::offset_of!(__UART_HandleTypeDef, AdvancedInit) - 36usize];
    ["Offset of field: __UART_HandleTypeDef::pTxBuffPtr"]
        [::core::mem::offset_of!(__UART_HandleTypeDef, pTxBuffPtr) - 76usize];
    ["Offset of field: __UART_HandleTypeDef::TxXferSize"]
        [::core::mem::offset_of!(__UART_HandleTypeDef, TxXferSize) - 80usize];
    ["Offset of field: __UART_HandleTypeDef::TxXferCount"]
        [::core::mem::offset_of!(__UART_HandleTypeDef, TxXferCount) - 82usize];
    ["Offset of field: __UART_HandleTypeDef::pRxBuffPtr"]
        [::core::mem::offset_of!(__UART_HandleTypeDef, pRxBuffPtr) - 84usize];
    ["Offset of field: __UART_HandleTypeDef::RxXferSize"]
        [::core::mem::offset_of!(__UART_HandleTypeDef, RxXferSize) - 88usize];
    ["Offset of field: __UART_HandleTypeDef::RxXferCount"]
        [::core::mem::offset_of!(__UART_HandleTypeDef, RxXferCount) - 90usize];
    ["Offset of field: __UART_HandleTypeDef::Mask"]
        [::core::mem::offset_of!(__UART_HandleTypeDef, Mask) - 92usize];
    ["Offset of field: __UART_HandleTypeDef::ReceptionType"]
        [::core::mem::offset_of!(__UART_HandleTypeDef, ReceptionType) - 96usize];
    ["Offset of field: __UART_HandleTypeDef::RxEventType"]
        [::core::mem::offset_of!(__UART_HandleTypeDef, RxEventType) - 100usize];
    ["Offset of field: __UART_HandleTypeDef::RxISR"]
        [::core::mem::offset_of!(__UART_HandleTypeDef, RxISR) - 104usize];
    ["Offset of field: __UART_HandleTypeDef::TxISR"]
        [::core::mem::offset_of!(__UART_HandleTypeDef, TxISR) - 108usize];
    ["Offset of field: __UART_HandleTypeDef::hdmatx"]
        [::core::mem::offset_of!(__UART_HandleTypeDef, hdmatx) - 112usize];
    ["Offset of field: __UART_HandleTypeDef::hdmarx"]
        [::core::mem::offset_of!(__UART_HandleTypeDef, hdmarx) - 116usize];
    ["Offset of field: __UART_HandleTypeDef::Lock"]
        [::core::mem::offset_of!(__UART_HandleTypeDef, Lock) - 120usize];
    ["Offset of field: __UART_HandleTypeDef::gState"]
        [::core::mem::offset_of!(__UART_HandleTypeDef, gState) - 124usize];
    ["Offset of field: __UART_HandleTypeDef::RxState"]
        [::core::mem::offset_of!(__UART_HandleTypeDef, RxState) - 128usize];
    ["Offset of field: __UART_HandleTypeDef::ErrorCode"]
        [::core::mem::offset_of!(__UART_HandleTypeDef, ErrorCode) - 132usize];
};
#[doc = " @brief  UART handle Structure definition"]
pub type UART_HandleTypeDef = __UART_HandleTypeDef;
#[doc = " @brief  UART wake up from stop mode parameters"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct UART_WakeUpTypeDef {
    #[doc = "< Specifies which event will activate the Wakeup from Stop mode flag (WUF).\nThis parameter can be a value of @ref UART_WakeUp_from_Stop_Selection.\nIf set to UART_WAKEUP_ON_ADDRESS, the two other fields below must\nbe filled up."]
    pub WakeUpEvent: u32,
    #[doc = "< Specifies whether the address is 4 or 7-bit long.\nThis parameter can be a value of @ref UARTEx_WakeUp_Address_Length."]
    pub AddressLength: u16,
    #[doc = "< UART/USART node address (7-bit long max)."]
    pub Address: u8,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of UART_WakeUpTypeDef"][::core::mem::size_of::<UART_WakeUpTypeDef>() - 8usize];
    ["Alignment of UART_WakeUpTypeDef"][::core::mem::align_of::<UART_WakeUpTypeDef>() - 4usize];
    ["Offset of field: UART_WakeUpTypeDef::WakeUpEvent"]
        [::core::mem::offset_of!(UART_WakeUpTypeDef, WakeUpEvent) - 0usize];
    ["Offset of field: UART_WakeUpTypeDef::AddressLength"]
        [::core::mem::offset_of!(UART_WakeUpTypeDef, AddressLength) - 4usize];
    ["Offset of field: UART_WakeUpTypeDef::Address"]
        [::core::mem::offset_of!(UART_WakeUpTypeDef, Address) - 6usize];
};
unsafe extern "C" {
    #[doc = " @addtogroup UARTEx_Exported_Functions_Group2\n @{"]
    pub fn HAL_UARTEx_WakeupCallback(huart: *mut UART_HandleTypeDef);
}
unsafe extern "C" {
    #[doc = " @addtogroup UARTEx_Exported_Functions_Group3\n @{"]
    pub fn HAL_UARTEx_StopModeWakeUpSourceConfig(
        huart: *mut UART_HandleTypeDef,
        WakeUpSelection: UART_WakeUpTypeDef,
    ) -> HAL_StatusTypeDef;
}
unsafe extern "C" {
    pub fn HAL_UARTEx_EnableStopMode(huart: *mut UART_HandleTypeDef) -> HAL_StatusTypeDef;
}
unsafe extern "C" {
    pub fn HAL_UARTEx_DisableStopMode(huart: *mut UART_HandleTypeDef) -> HAL_StatusTypeDef;
}
unsafe extern "C" {
    pub fn HAL_UARTEx_ReceiveToIdle(
        huart: *mut UART_HandleTypeDef,
        pData: *mut u8,
        Size: u16,
        RxLen: *mut u16,
        Timeout: u32,
    ) -> HAL_StatusTypeDef;
}
unsafe extern "C" {
    pub fn HAL_UARTEx_ReceiveToIdle_IT(
        huart: *mut UART_HandleTypeDef,
        pData: *mut u8,
        Size: u16,
    ) -> HAL_StatusTypeDef;
}
unsafe extern "C" {
    pub fn HAL_UARTEx_ReceiveToIdle_DMA(
        huart: *mut UART_HandleTypeDef,
        pData: *mut u8,
        Size: u16,
    ) -> HAL_StatusTypeDef;
}
unsafe extern "C" {
    pub fn HAL_UARTEx_GetRxEventType(
        huart: *const UART_HandleTypeDef,
    ) -> HAL_UART_RxEventTypeTypeDef;
}
unsafe extern "C" {
    #[doc = " @addtogroup UART_Exported_Functions_Group1 Initialization and de-initialization functions\n @{"]
    pub fn HAL_UART_Init(huart: *mut UART_HandleTypeDef) -> HAL_StatusTypeDef;
}
unsafe extern "C" {
    pub fn HAL_UART_DeInit(huart: *mut UART_HandleTypeDef) -> HAL_StatusTypeDef;
}
unsafe extern "C" {
    pub fn HAL_UART_MspInit(huart: *mut UART_HandleTypeDef);
}
unsafe extern "C" {
    pub fn HAL_UART_MspDeInit(huart: *mut UART_HandleTypeDef);
}
unsafe extern "C" {
    #[doc = " @addtogroup UART_Exported_Functions_Group2 IO operation functions\n @{"]
    pub fn HAL_UART_Transmit(
        huart: *mut UART_HandleTypeDef,
        pData: *const u8,
        Size: u16,
        Timeout: u32,
    ) -> HAL_StatusTypeDef;
}
unsafe extern "C" {
    pub fn HAL_UART_Receive(
        huart: *mut UART_HandleTypeDef,
        pData: *mut u8,
        Size: u16,
        Timeout: u32,
    ) -> HAL_StatusTypeDef;
}
unsafe extern "C" {
    pub fn HAL_UART_Transmit_IT(
        huart: *mut UART_HandleTypeDef,
        pData: *const u8,
        Size: u16,
    ) -> HAL_StatusTypeDef;
}
unsafe extern "C" {
    pub fn HAL_UART_Receive_IT(
        huart: *mut UART_HandleTypeDef,
        pData: *mut u8,
        Size: u16,
    ) -> HAL_StatusTypeDef;
}
unsafe extern "C" {
    pub fn HAL_UART_Transmit_DMA(
        huart: *mut UART_HandleTypeDef,
        pData: *const u8,
        Size: u16,
    ) -> HAL_StatusTypeDef;
}
unsafe extern "C" {
    pub fn HAL_UART_Receive_DMA(
        huart: *mut UART_HandleTypeDef,
        pData: *mut u8,
        Size: u16,
    ) -> HAL_StatusTypeDef;
}
unsafe extern "C" {
    pub fn HAL_UART_DMAPause(huart: *mut UART_HandleTypeDef) -> HAL_StatusTypeDef;
}
unsafe extern "C" {
    pub fn HAL_UART_DMAResume(huart: *mut UART_HandleTypeDef) -> HAL_StatusTypeDef;
}
unsafe extern "C" {
    pub fn HAL_UART_DMAStop(huart: *mut UART_HandleTypeDef) -> HAL_StatusTypeDef;
}
unsafe extern "C" {
    pub fn HAL_UART_Abort(huart: *mut UART_HandleTypeDef) -> HAL_StatusTypeDef;
}
unsafe extern "C" {
    pub fn HAL_UART_AbortTransmit(huart: *mut UART_HandleTypeDef) -> HAL_StatusTypeDef;
}
unsafe extern "C" {
    pub fn HAL_UART_AbortReceive(huart: *mut UART_HandleTypeDef) -> HAL_StatusTypeDef;
}
unsafe extern "C" {
    pub fn HAL_UART_Abort_IT(huart: *mut UART_HandleTypeDef) -> HAL_StatusTypeDef;
}
unsafe extern "C" {
    pub fn HAL_UART_AbortTransmit_IT(huart: *mut UART_HandleTypeDef) -> HAL_StatusTypeDef;
}
unsafe extern "C" {
    pub fn HAL_UART_AbortReceive_IT(huart: *mut UART_HandleTypeDef) -> HAL_StatusTypeDef;
}
unsafe extern "C" {
    pub fn HAL_UART_IRQHandler(huart: *mut UART_HandleTypeDef);
}
unsafe extern "C" {
    pub fn HAL_UART_TxHalfCpltCallback(huart: *mut UART_HandleTypeDef);
}
unsafe extern "C" {
    pub fn HAL_UART_TxCpltCallback(huart: *mut UART_HandleTypeDef);
}
unsafe extern "C" {
    pub fn HAL_UART_RxHalfCpltCallback(huart: *mut UART_HandleTypeDef);
}
unsafe extern "C" {
    pub fn HAL_UART_RxCpltCallback(huart: *mut UART_HandleTypeDef);
}
unsafe extern "C" {
    pub fn HAL_UART_ErrorCallback(huart: *mut UART_HandleTypeDef);
}
unsafe extern "C" {
    pub fn HAL_UART_AbortCpltCallback(huart: *mut UART_HandleTypeDef);
}
unsafe extern "C" {
    pub fn HAL_UART_AbortTransmitCpltCallback(huart: *mut UART_HandleTypeDef);
}
unsafe extern "C" {
    pub fn HAL_UART_AbortReceiveCpltCallback(huart: *mut UART_HandleTypeDef);
}
unsafe extern "C" {
    pub fn HAL_UARTEx_RxEventCallback(huart: *mut UART_HandleTypeDef, Size: u16);
}
unsafe extern "C" {
    #[doc = " @addtogroup UART_Exported_Functions_Group3 Peripheral Control functions\n @{"]
    pub fn HAL_UART_ReceiverTimeout_Config(huart: *mut UART_HandleTypeDef, TimeoutValue: u32);
}
unsafe extern "C" {
    pub fn HAL_UART_EnableReceiverTimeout(huart: *mut UART_HandleTypeDef) -> HAL_StatusTypeDef;
}
unsafe extern "C" {
    pub fn HAL_UART_DisableReceiverTimeout(huart: *mut UART_HandleTypeDef) -> HAL_StatusTypeDef;
}
unsafe extern "C" {
    #[doc = " @addtogroup UART_Exported_Functions_Group4 Peripheral State and Error functions\n @{"]
    pub fn HAL_UART_GetState(huart: *const UART_HandleTypeDef) -> HAL_UART_StateTypeDef;
}
unsafe extern "C" {
    pub fn HAL_UART_GetError(huart: *const UART_HandleTypeDef) -> u32;
}
unsafe extern "C" {
    pub fn HAL_Delay(Delay: u32);
}
unsafe extern "C" {
    pub fn Error_Handler();
}
unsafe extern "C" {
    pub static mut huart2: UART_HandleTypeDef;
}
